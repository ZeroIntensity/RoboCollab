
Developed by [ZeroIntensity](https://github.com/ZeroIntensity), under the MIT License.


# RoboCollab SQL

## Usage
### Parameters
|Name|Type|Description|Notes|Example|
|---|---|---|---|---|
|**rc_id**|integer|Unique key for each column.|Set as the primary key.|`1`|
|**dc_id**|integer|ID of the discord guild where the collab was created.|Not generated by RoboCollab itself, grabbed from the Discord API.|`754902431258771567`|
|**data_placement**|string|Path of JSON file which holds rest of collab data.|Must be unique and a full path.|`'C:\mycollab_754902431258771567.json'`|
|**name**|string|Name of collab.|Must be unique and cannot hold more than 20 characters.|`'mycollab'`|
### Files
|Name|Description|Notes|
|---|---|---|
|`init.sql`|Initalize database if it **does not exist**.|Ran in `main.py` on every instance.|
|`get_all_data.sql`|Get all data from database.||
|`get_collabs_by_dc_id.sql`|Get all columns with a certain Discord Guild ID|Must be run from the `SQL()` function inside RoboCollab utils to pass in arguments correctly.|
|`add_to_table.sql`|Insert values into a column.|Also must to run from the `SQL()` function.|
## Running SQL Files
### What is the `SQL()` function
All RoboCollab SQL files are ran via the `SQL()` function.

 **Why is this done?**
 
  Because this function allows `.sql` files to run instead of copy pasting SQL code throughout the project, easily allows arguments to be passed straight into the file, and can get queries without having tons of `sqlite3` connections and cursors everywhere.

  **How do I use it?**
  

  You can easily import the function by doing `from utils import SQL`. Now, you have to create your SQL file. To make thing's easier, the function automatically searches the `sql` directory for the file, so all you have to do is add your file to the `sql` directory. Now after you are done writing your code, you can use `SQL('myfile.sql')`, to run it. If the file returns a query, then you can run the function as a variable, like this: `resp: list = SQL('myfile.sql')`. This will return a `list` of `tuples`. Each tuple represents a column, and the tuples contents represents the value in the column. Now for passing in arguments, it's very simple. First off, you need to set where the variable will be passed in. You can do this by surrounding the variable name with curly brackets in your file, `{like_this}`. Put this in your SQL file. **Here's an example:**
  ```sql
SELECT * FROM collab_data WHERE dc_id = {variable_1};
  ```
   Now, in the `SQL()` function call, after passing in the SQL file name, you pass in a dictionary. Keys in this dictionary should be the name of the variables in the SQL file, and the values should be what the variable value is. **Here's an example:**

  ```python
  vals = {
      "variable_1": "736038441384542268"
  }

  resp: list = SQL("file.sql", vals)
  ```

  Doing this would run **this SQL code:**

```sql
SELECT * FROM collab_data WHERE dc_id = 736038441384542268;
```
**Warning:** If you want to pass in a string, instead of doing `"variable_1": "736038441384542268"`, you need to do `"variable_1": "'736038441384542268'"`

## Notes
- SQL Injection **is not** an issue.
- All SQL statements are performed with the python `SQLite3` library by running files from the `sql` directory.
- Although it is not required for some files to use the `SQL()` function, it is **highly recommended** that you do.
